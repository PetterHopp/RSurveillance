method<- 1           # 1 = PPS, 0 = SRS
prev<- 0.5           # assumed prevalence
s.wti<- 0.2           # within cluster variance
s.wtb<- 0.05           # between cluster variance
N.avg<- 200           # mean cluster size
clusters<- 800       # number of clusters
c1<- 1000            # cost per cluster
c2<- 10             # cost per animal
fix.rel<- 1         # 1 = fixed CI, 0 = relative CI
error<- 0.05        # allowable error (desired precision)
conf<- 0.95         # desired confidence level
tails.conf<- 2      # 2-tailed test
digits<- 3
# z value
z.conf<- qnorm(1 - (1 - conf)/tails.conf, 0, 1)
method.lst<- c("PPS Sampling", "SRS Sampling")
inputs<- array(0, dim = c(11, 1))
rownames(inputs)<- c("Sampling Method", "Est. prevalence", "Within cluster variance", "Between cluster variance",
"Average cluster size", "Number of clusters", "Cost per cluster", "Cost per animal",
"Error method", "Error limit", "Confidence level")
inputs[1]<- method.lst[method]
d<- ceiling(-log10(prev))
inputs[2]<- format(prev, nsmall = d)
d<- ceiling(-log10(s.wti))
inputs[3]<- format(s.wti, nsmall = d)
d<- ceiling(-log10(s.wtb))
inputs[4]<- format(s.wtb, nsmall = d)
inputs[5]<- N.avg
inputs[6]<- clusters
inputs[7]<- c1
inputs[8]<- c2
inputs[9]<- ifelse(fix.rel, "Fixed Width", "Constant relative error")
d<- ceiling(-log10(error))
inputs[10]<- paste("+/-", format(error, nsmall = d))
inputs[11]<- paste(round(100*conf, 0), "%", sep = "")
View(inputs)
pps.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
if (fix.rel) {
m<- s.wtb/((error/z.conf)^2)
} else {
m<- s.wtb/(prev^2 * error^2)
}
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar)
return(result)
} # end of pps.vals
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg))))
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- paste(round(100*n.bar/N.avg, 1), "%", sep = "")
result<- list("Clusters" = round(m, 0), "Animals" = round(n.bar, 0), "SamplingFraction" = f.2)
return(result)
} # end of srs.vals
tmp<- pps.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
result<- array("", dim = c(length(tmp)+1, 1))
rownames(result)<- c("Clusters to sample", "Animals to sample per village", "Total animals to sample")
result
tmp<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
result<- array("", dim = c(length(tmp)+1, 1))
rownames(result)<- c("Clusters to sample", "Average animals to sample per village", "Sampling fraction per village", "Total animals to sample")
result
tmp
tmp<- pps.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
result<- array("", dim = c(length(tmp)+1, 1))
rownames(result)<- c("Clusters to sample", "Animals to sample per village", "Total animals to sample")
tmp
pps.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
if (fix.rel) {
m<- s.wtb/((error/z.conf)^2)
} else {
m<- s.wtb/(prev^2 * error^2)
}
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "Total" = round(m, 0)*n.bar)
return(result)
} # end of pps.vals
tmp<- pps.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
tmp
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg))))
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- paste(round(100*n.bar/N.avg, 1), "%", sep = "")
result<- list("Clusters" = round(m, 0), "Animals" = round(n.bar, 0), "SamplingFraction" = f.2)
return(result)
} # end of srs.vals
tmp<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
tmp
# calculate sample size for SRS sampling
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg))))
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- paste(round(100*n.bar/N.avg, 1), "%", sep = "")
result<- list("Clusters" = round(m, 0), "Animals" = round(n.bar, 0), "SamplingFraction" = f.2, "Total" = round(m, 0)*round(n.bar,0))
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
######################################
# Program to do two stage prevalence estimates - sample size
######################################
rm(list = ls())
# input values
method<- 1           # 1 = PPS, 0 = SRS
prev<- 0.5           # assumed prevalence
s.wti<- 0.2           # within cluster variance
s.wtb<- 0.05           # between cluster variance
N.avg<- 200           # mean cluster size
clusters<- 800       # number of clusters
c1<- 1000            # cost per cluster
c2<- 10             # cost per animal
fix.rel<- 1         # 1 = fixed CI, 0 = relative CI
error<- 0.05        # allowable error (desired precision)
conf<- 0.95         # desired confidence level
tails.conf<- 2      # 2-tailed test
digits<- 3
# z value
z.conf<- qnorm(1 - (1 - conf)/tails.conf, 0, 1)
method.lst<- c("PPS Sampling", "SRS Sampling")
inputs<- array(0, dim = c(11, 1))
rownames(inputs)<- c("Sampling Method", "Est. prevalence", "Within cluster variance", "Between cluster variance",
"Average cluster size", "Number of clusters", "Cost per cluster", "Cost per animal",
"Error method", "Error limit", "Confidence level")
inputs[1]<- method.lst[method]
d<- ceiling(-log10(prev))
inputs[2]<- format(prev, nsmall = d)
d<- ceiling(-log10(s.wti))
inputs[3]<- format(s.wti, nsmall = d)
d<- ceiling(-log10(s.wtb))
inputs[4]<- format(s.wtb, nsmall = d)
inputs[5]<- N.avg
inputs[6]<- clusters
inputs[7]<- c1
inputs[8]<- c2
inputs[9]<- ifelse(fix.rel, "Fixed Width", "Constant relative error")
d<- ceiling(-log10(error))
inputs[10]<- paste("+/-", format(error, nsmall = d))
inputs[11]<- paste(round(100*conf, 0), "%", sep = "")
# calculate sample size for PPS sampling
pps.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
if (fix.rel) {
m<- s.wtb/((error/z.conf)^2)
} else {
m<- s.wtb/(prev^2 * error^2)
}
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "Total" = round(m, 0)*n.bar)
return(result)
} # end of pps.vals
pps<- pps.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
pps
# calculate sample size for SRS sampling
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg))))
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- paste(round(100*n.bar/N.avg, 1), "%", sep = "")
result<- list("Clusters" = round(m, 0), "Animals" = round(n.bar, 0), "SamplingFraction" = f.2, "Total" = round(m, 0)*round(n.bar,0))
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
inputs
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg))))
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- round(100*n.bar/N.avg, 1)
result<- list("Clusters" = round(m, 0), "Animals" = round(n.bar, 0), "SamplingFraction" = f.2, "Total" = round(m, 0)*round(n.bar,0))
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- round(n.bar/N.avg, 3)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "SamplingFraction" = f.2, "Total" = round(m, 0)*n.bar))
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- round(n.bar/N.avg, 3)
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- round(n.bar/N.avg, 3)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "SamplingFraction" = f.2, "Total" = round(m, 0)*n.bar)
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- n.bar/N.avg
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "SamplingFraction" = f.2, "Total" = round(m, 0)*n.bar)
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
inputs<- array(0, dim = c(11, 1))
rownames(inputs)<- c("Sampling Method", "Est. prevalence", "Within cluster variance", "Between cluster variance",
"Average cluster size", "Number of clusters", "Cost per cluster", "Cost per animal",
"Error method", "Error limit", "Confidence level")
inputs[1]<- method.lst[method]
# d<- ceiling(-log10(prev))
inputs[2]<- format(prev, nsmall = d)
# d<- ceiling(-log10(s.wti))
inputs[3]<- format(s.wti, nsmall = d)
# d<- ceiling(-log10(s.wtb))
inputs[4]<- format(s.wtb, nsmall = d)
inputs[5]<- N.avg
inputs[6]<- clusters
inputs[7]<- c1
inputs[8]<- c2
inputs[9]<- ifelse(fix.rel, "Fixed Width", "Constant relative error")
# d<- ceiling(-log10(error))
inputs[10]<- paste("+/-", format(error, nsmall = d))
inputs[11]<- paste(round(100*conf, 0), "%", sep = "")
inputs
inputs[1]<- method.lst[method]
inputs[2]<- format(prev, nsmall = d)
inputs[3]<- format(s.wti, nsmall = d)
inputs[4]<- format(s.wtb, nsmall = d)
inputs[5]<- N.avg
inputs[6]<- clusters
inputs[7]<- c1
inputs[8]<- c2
inputs[9]<- ifelse(fix.rel, "Fixed Width", "Constant relative error")
inputs[10]<- paste("+/-", format(error, nsmall = d))
inputs[11]<- paste(round(100*conf, 0), "%", sep = "")
# calculate sample size for PPS sampling
pps.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
if (fix.rel) {
m<- s.wtb/((error/z.conf)^2)
} else {
m<- s.wtb/(prev^2 * error^2)
}
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "Total" = round(m, 0)*n.bar)
return(result)
} # end of pps.vals
pps<- pps.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
pps
# calculate sample size for SRS sampling
srs.vals<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- n.bar/N.avg
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "SamplingFraction" = f.2, "Total" = round(m, 0)*n.bar)
return(result)
} # end of srs.vals
srs<- srs.vals(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
srs
######################################
# Estimate sample size for two stage prevalence estimates
######################################
rm(list = ls())
# input values
method<- 1           # 1 = PPS, 0 = SRS
prev<- 0.5           # assumed prevalence
s.wti<- 0.2           # within cluster variance
s.wtb<- 0.05           # between cluster variance
N.avg<- 200           # mean cluster size
clusters<- 800       # number of clusters
c1<- 1000            # cost per cluster
c2<- 10             # cost per animal
fix.rel<- 1         # 1 = fixed CI, 0 = relative CI
error<- 0.05        # allowable error (desired precision)
conf<- 0.95         # desired confidence level
tails.conf<- 2      # 2-tailed test
digits<- 3
# z value
z.conf<- qnorm(1 - (1 - conf)/tails.conf, 0, 1)
method.lst<- c("PPS Sampling", "SRS Sampling")
inputs<- array(0, dim = c(11, 1))
rownames(inputs)<- c("Sampling Method", "Est. prevalence", "Within cluster variance", "Between cluster variance",
"Average cluster size", "Number of clusters", "Cost per cluster", "Cost per animal",
"Error method", "Error limit", "Confidence level")
inputs[1]<- method.lst[method]
inputs[2]<- format(prev, nsmall = d)
inputs[3]<- format(s.wti, nsmall = d)
inputs[4]<- format(s.wtb, nsmall = d)
inputs[5]<- N.avg
inputs[6]<- clusters
inputs[7]<- c1
inputs[8]<- c2
inputs[9]<- ifelse(fix.rel, "Fixed Width", "Constant relative error")
inputs[10]<- paste("+/-", format(error, nsmall = d))
inputs[11]<- paste(round(100*conf, 0), "%", sep = "")
inputs
# calculate sample size for PPS sampling
n.pps<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
if (fix.rel) {
m<- s.wtb/((error/z.conf)^2)
} else {
m<- s.wtb/(prev^2 * error^2)
}
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "Total" = round(m, 0)*n.bar)
return(result)
} # end of pps.vals
n<- n.pps(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
n
# calculate sample size for SRS sampling
n.srs<- function(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg) {
n.bar<- round(sqrt((c1/c2) * (s.wti/(s.wtb - (s.wti/N.avg)))), 0)
if (fix.rel) {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error/z.conf)^2 + (s.wtb/(N.avg*clusters)))
} else {
m<- (s.wtb - (s.wti/N.avg) + (s.wti/n.bar))/((error^2 * prev^2) + (s.wtb/(N.avg*clusters)))
}
f.2<- n.bar/N.avg
result<- list("Clusters" = round(m, 0), "Animals" = n.bar, "SamplingFraction" = f.2, "Total" = round(m, 0)*n.bar)
return(result)
} # end of srs.vals
n<- n.srs(fix.rel, s.wtb, error, z.conf, prev, c1, c2, s.wti, N.avg)
n
inputs
d<- 3               # number of digits
# z value
z.conf<- qnorm(1 - (1 - conf)/tails.conf, 0, 1)
method.lst<- c("PPS Sampling", "SRS Sampling")
inputs<- array(0, dim = c(11, 1))
rownames(inputs)<- c("Sampling Method", "Est. prevalence", "Within cluster variance", "Between cluster variance",
"Average cluster size", "Number of clusters", "Cost per cluster", "Cost per animal",
"Error method", "Error limit", "Confidence level")
inputs[1]<- method.lst[method]
inputs[2]<- format(prev, nsmall = d)
inputs[3]<- format(s.wti, nsmall = d)
inputs[4]<- format(s.wtb, nsmall = d)
inputs[5]<- N.avg
inputs[6]<- clusters
inputs[7]<- c1
inputs[8]<- c2
inputs[9]<- ifelse(fix.rel, "Fixed Width", "Constant relative error")
inputs[10]<- paste("+/-", format(error, nsmall = d))
inputs[11]<- paste(round(100*conf, 0), "%", sep = "")
inputs
##'   assuming imperfect test sensitivity and perfect test specificity
sep.var.se<- function(N=NA, se, pstar) {
if (!(is.na(N)) & N < length(se)) return("Error: N cannot be less than the number of sensitivity values")
if (is.na(N)) {
sep<- 1-prod(1-se*pstar)
} else {
if (pstar < 1 & pstar > 0) pstar<- ceiling(N*pstar)
sep<- 1-(1-mean(se)*length(se)/N)^pstar
}
return(sep)
}
sep.var.se(500, runif(150, 0.95, 0.99), 0.02)
